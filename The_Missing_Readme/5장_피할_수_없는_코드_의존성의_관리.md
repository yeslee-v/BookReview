# 5장 피할 수 없는 코드 의존성의 관리

- 이행적 의존성(transitive dependency)은 본질적으로 바이럴한 특성이 있다.

- 같은 일은 반복하지 말라(DRY; Don't repeat yourself)

- 의존성을 추가할 때는 다양한 위험(호환성 없는 변경, 순환 의존성, 버전 충돌, 통제 불가능 등)을 인지하고 사전에 완화할 수 있는 방법을 고려해야 한다.

## 의존성 관리를 이해하기 위한 필수 개념

- 의존성(dependency)란 여러분의 코드가 의존하는 코드로 패키지 관리 파일 또는 빌드 파일에 선언한다.

  - 자바: Gradle, Maven

  - 파이썬: setup.py, requrements.txt

  - 자바스크립트: npm package.json

- 의존성 범위(scope)는 컴파일 시점, 테스트, 런타임 등을 의미한다.

- 의존성은 컴파일하기 위해 필요하다.

- 패키지의 버전은 의존성을 변경하고 동일 패키지의 다른 버전이 등장할 경우 충돌을 해결하는데 주로 사용된다.

- 버저닝 스키마(versioning scheme; 소프트웨어 버전을 체계적으로 관리하고 표현하는 방식)을 잘 따르는 버전의 특징

  - 고유성: 버전은 재사용되지 않는다. 변경된 코드를 이미 존재하는 버전으로 재배포해서는 안 된다.

  - 비교성: 버전은 사람과 도구가 우선권(precedence)를 이해하는데 도움이 된다.

  - 정보성: 버전은 사전 릴리즈(prerelease)한 코드와 정식 릴리즈한 코드를 구분하고 산출물에 빌드 번호를 매기며 안정성과 호환성을 설명한다.

### 시맨틱 버저닝(SemVer; semantic versioning)

- 주(major) 버전, 보조(minor) 버전, 패치(patch) 버전 등 3개의 숫자로 버전을 정의한다.
- 버전 번호는 MAJOR.MINOR.PATCH 형식으로 조합한다.

- 시맨틱 버전은 고유성과 비교성, 정보성을 모두 갖추고 있다.

- 주버전이 0인 버전은 '사전 릴리즈'로 개발 주기를 빠르게 가져가기 위해 사용하고 호환성은 보장되지 않는다.

- 주버전이 1인 프로젝트가 보장해야하는 조건들

  - 패치 버전: 하위 호환성을 갖는 버그 수정이 일어날 때마다 증가한다.

  - 보조 버전: 하위 호환성을 갖는 기능을 추가할 때마다 증가한다.

  - 주 버전: 하위 호환성을 갖지 못하는 변경을 추가할 때 증가한다.

- 사전 릴리즈 버전은 마침표로 구분한 영문자와 숫자(예. 2.1.4-alpha.1)로 표현한다.

- 버전 및 사전 릴리즈 메타데이터 뒤에 빌드 번호(예. 2.1.4-alpha.1+1992)를 붙이면 개발자나 도구가 컴파일에 성공한 버전에 대한 빌드 로그를 찾는데 도움이 된다.

- 버그가 수정된 버전과 새 기능이 탑재된 버전이 자동으로 다운로드되더라도 빌드는 계속 동작해야 한다.

### 이행적 의존성(transitive dependency)

- 의존성은 다른 라이브러리에 주로 의존한다.

- 의존성 보고서는 완전히 해석된 의존성 트리 또는 의존성 그래프를 보여준다.

- 의존성 트리는 빌드 시스템이 프로젝트를 컴파일할 때 실제로 사용하는 의존성을 보여준다.

- 의존성 충돌을 디버깅하려면 의존성 트리를 확인하는 방법을 익혀두어야 한다.

## 현업이면 누구나 한 번은 겪는 의존성 지옥(dependency hell)

- 다이아몬드 의존성: 하나의 프로젝트는 버전이 서로 다른 두 라이브러리를 동시에 사용할 수 없다.

- 순환 의존성(circular dependency): 라이브러리가 자신을 이행적 의존성으로 갖는다.

- 버전 충돌

## 의존성 지옥에서 탈출하자

- DLL 지옥, JAR 지옥, pip를 건드려야 하는 모든 경우 등이 있다.

- 의존성의 가치가 의존성이 추가됐을 때 발생하는 비용보다 큰지 생각해보자.

  - 이 기능은 정말 필요한가?

  - 의존성은 얼마나 잘 관리되고 있는가?

  - 뭔가 잘못됐을 때 의존성을 수정하는 것은 얼마나 쉬운가?

  - 의존성은 얼마나 성숙한가?

  - 의존성에서 하위 호환되지 않는 변경이 얼마나 자주 일어나는가?

  - 나 자신과 우리 팀, 우리 조직은 의존성에 대해 얼마나 이해하고 있는가?

  - 코드를 직접 작성한다면 구현 난이도는 어느 정도인가?

  - 어떤 유형의 코드 라이선스가 적용되어 있는가?

  - 의존성 내에서 내가 사용하는 코드와 사용하지 않는 코드의 비율은 어느 정도인가?

### 의존성을 격리하자

- 코드 복사는 작고 안정적인 코드가 필요할 때만 선택할 수 있는 옵션이다.

- 의존성 가리기(충돌을 피하기 위해 의존성을 다른 네임스페이스로 자동 이전하는 기법)는 라이브러리가 자신의 의존성을 애플리케이션에 강제하지 않게 하는 방법이다.

- 의존성 가리기는 반드시 필요한 경우에만 활용하고, 가려진 의존성 객체는 공개 API에 노출되어서는 안 된다.(목적 위배)

- 충돌이 발생할 가능성이 높은 의존성을 광범위하게 사용하는 라이브러리를 만들 때만 의존성 가리기 기법을 적용해보자.

### 의존성은 신중하게 추가하자

- 사용하는 모든 라이브러리는 명시적으로 의존성을 선언하자.

- IDE에만 의존해 의존성을 관리하지 말고 명시적으로 빌드 파일에 추가하자.

- 빌드 머신은 IDE 자체 설정을 참조하지 않아 일관성이 없을 수 있다.

### 버전을 고정하자

- 모든 의존성의 버전 번호를 명시(버전 고정; version pinning)하자.

- 버전을 고정하지 않으면 빌드나 패키지 관리 시스템이 버전을 결정한다.

- 버전 범위의 경계를 지정하는 것도 하나의 방법이다.

### 의존성의 범위를 좁히자

- 의존성의 '범위'는 의존성이 빌드 수명주기 내에서 언제 사용되는 것인지 결정한다.

- 의존성은 충돌과 런타임 바이너리의 크기를 줄일 수 있도록 최대한 범위를 좁혀서 사용해야 한다.

### 순환 의존성에 주의하자

- 순환 의존성은 시스템의 오작동과 배포 순서 문제를 유발한다.

- 빌드 도구나 플러그인 등으로 순환 의존성으로부터 보호하자.

## 개발자의 필수 체크리스트

### 이것만은 지키자

- 시맨틱 버저닝을 사용하자.

- 의존성 버전은 특정 범위로 고정하자.

- 의존성 보고서를 이용해 이행적 의존성을 파악하자.

- 새 의존성 추가는 가급적 피하자.

- 의존성은 적당한 범위 내에 선언하자.

### 이것만은 피하자

- 깃 해지를 버전 번호로 사용하지 말자.

- 비용 대비 효과가 낮다면 의존성을 추가하지 말자.

- 이행적 의존성을 직접 사용해서는 안 된다.

- 순환 의존성을 추가하지 말자.

## 레벨업을 위한 읽을거리

- [시맨틱 버저닝 스펙](https://semver.org/)

- 파이썬도 비슷한 [버저닝 스키마를 지원](https://peps.python.org/pep-0440/)한다.