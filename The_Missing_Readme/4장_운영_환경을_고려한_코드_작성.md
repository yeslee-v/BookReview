# 4장 운영 환경을 고려한 코드 작성

- 운영 가능한 코드란 보호 장치, 분석 장치, 제어 장치가 내장된 코드(operable code)를 말한다.
 
- 안전한 코드는 다양한 장애를 극복하며, 회복성을 갖춘 코드는 장애가 발생해도 복구가 가능하다.

## 장애에 대비하기 위한 방어적 프로그래밍 방안

- 코드를 안전하고 회복성있게 만들자.

- 안전한 코드(safe code)를 위해 컴파일 타임의 유효성 검사를 통해 런타임 장애를 최소화하고 불변 변수(immutable variable)를 사용하고 접근 제어자(access modifier)를 이용해 범위를 제한하며 정적 타입 검사기를 통해 버그를 줄이자.

- 런타임에 예상치 못한 일이 벌어지지 않도록 입력값을 검사하자.

- 회복성있는 코드(resilient code)는 권장되는 예외 처리 기법을 활용하며 장애를 적절하게 처리한다.

### null 값 사용은 피하자

- 널 포인터 예외(null pointer exception)는 매우 보편적으로 발생한다.

- 변수가 null 값을 갖진 않는지 검사하거나 null 객체 패턴(null object pattern)이나 옵션 타입(option type)등을 사용해 방지하자.

- null 검사는 메서드의 시작 지점에서 해야 한다.

- null 객체 패턴은 null 값 대신에 객체를 사용하는 패턴이다.

  - 예. 원하는 객체를 찾지 못했을 때 null이 아닌 빈 배열을 리턴하는 검색 메서드

- 옵션 타입(Optional 또는 Maybe 등)이 내장된 언어라면 옵션 타입을 활용하자.

### 불변 변수를 사용하자

- 불변 변수는 의도치 않게 변수의 값이 바뀌는 상황을 미연에 방지해준다.

- 병렬 프로그래밍이 간단해지면서 변수 값이 바뀌지 않을 것을 인지하는 컴파일러나 런타임은 더욱 효율적으로 동작할 수 있다.

### 타입 힌트나 정적 타입 검사를 사용하자

- 변수가 보관할 수 있는 값을 제한하자.

- 변수를 선언할 때는 가장 구체적인 타입을 사용하자.

- 타입 힌트(type hint)를 활용하면 동적 타입이던 변수에 타입을 지정할 수 있어 기존의 코드베이스에 점진적으로 추가할 수 있다.

- 정적 타입 검사기까지 도입한다면 런타임 에러를 피할 수 있다.

### 입력값을 검사하자

- 코드로 전달되는 입력값을 절대적으로 신뢰하지 말자.

- 원치 않은 입력값이 전달되면 최대한 이른 시점에 실행을 거부하도록 조치해두자.

- 최대한 많이 검사하자.

- 컴퓨터 하드웨어가 항상 믿을 만한 존재는 아니므로 의도치 않은 데이터 변경이 일어나지 않았는지 checksum을 이용해 확인해야 한다.

- 검증된 라이브러리와 프레임워크를 이용해서 cross site scripting을 방지하자.

- 보안 및 암호화 라이브러리나 프로토콜은 직접 작성하지 말고 널리 사용되는 것을 활용하자.

  - [공개 웹 애플리케이션 보안 프로젝트(OWASP; Open Web Application Security Project) 상위 10개 보안 위협 보고서](https://owasp.org/www-project-top-ten/)

### 예외를 활용하자

- 특정 리턴 값이 아닌 개발 언어에 내장되어 있는 예외나 표준 예외 처리 패턴을 활용하자.

### 예외는 구체적으로 사용하자

- 가능하면 언어에 내장된 예외를 사용하고 포괄적인 의미를 담는 예외는 만들지 말자.

- 예외는 애플리케이션 로직을 제어하는 용도가 아니라 실패를 처리할 때만 사용해야 한다.

### 예외는 일찍 던지고 최대한 나중에 처리하자

- '일찍 던지고(throw early) 늦게 잡는(catch exception late)' 원칙을 따르자.

- 데이터베이스의 로그 선행 기입(write-ahead)은 반드시 기록돼야 하는 반면 워드프로세서의 백그라운드 저장 기능은 조금 늦게 실행돼도 무방하다.

- 호출하는 코드가 예외를 던지면 예외를 완전히 처리하거나 혹은 상위 스택으로 전파하자.

### 재시도는 현명하게

- 에러를 적절하게 처리하는 방법 중 하나는 단순히 다시 시도하는 것이다.

- 비선형으로 대기 시간을 늘리는 백오프(backoff) 전략을 사용하되, 백오프 시간의 상한선을 정해 대기 시간이 너무 길어지지 않게 하자.

- 네트워크 서버 문제로 모든 클라이언트가 동일한 백오프 알고리즘을 사용해 동시에 재시도 요청을 보내(thundering herd) 복구 중인 서비스가 다시 다운된다면, 백오프 전략에 지터(jitter)를 추가할 수 있다.

- 지터를 추가하면 클라이언트들은 특정 범위에서 임의의 값을 백오프 시간에 더한다.

- 실패한 요청을 무턱대고 재시도하지 말자.

- 설계 시점에서 처리를 염두에 두지 않은 에러가 발생하면 차라리 애플리케이션이 crash되도록 놔두는 것이 낫다(failing fast)

- 실패할 수 밖에 없다면 빨리 실패하고 실패 상황을 전파하는 방안도 생각해야 한다.

### 시스템에 멱등성을 부여하자

- 원격 시스템을 확인할 수 있는 경우도 있지만 항상 가능한 것은 아니다.

- 재시도를 처리하는 가장 좋은 방법은 멱등성(idempotent; 동일한 작업을 여러 번 실행해도 항상 같은 값이 출력)있는 시스템을 구현하는 것이다.

- 모든 작업을 멱등성있게 구현하면 시스템의 상호작용이 훨씬 간단해지며 발생 가능한 에러도 현저히 줄어든다.

### 리소스를 해제하자

- 장애가 발생하면 모든 리소스를 해제해야 한다.

- 현대 개발 언어들 대부분이 자동 리소스 해제 기능을 지원한다.

## 문제 원인을 찾기 위한 로깅 방안

- 코드를 쉽게 운영하고 디버그할 수 있도록 로깅 프레임워크를 활용하자.

- 로그 레벨을 설정해서 운영자가 애플리케이션의 로그 양을 조정할 수 있게 하자.

- 로그는 원자적이고 빠르며 안전하게 다뤄야 한다.

### 로그 레벨을 사용하자

- 로깅 프레임워크는 운영자가 중요도에 따라 메시지를 필터링할 수 있도록 로그 레벨(log level)을 지원한다.

- 로그 레벨은 주로 전역 설정을 통해 관리하며 패키지나 클래스 수준에서 재설정도 가능하다.

- 로그 레벨을 제대로 활용하려면 각 로그 메시지에 적절한 중요도를 지정해야 한다.

  - TRACE: 특정 패키지나 클래스에서만 켜지며 최대한 상세한 내용을 출력하는 레벨. 줄 단위 로그나 데이터 구조를 확인할 때 사용한다.

  - DEBUG: 프로덕션 상황에서 문제가 발생했을 때 적합한 레벨. 너무 많이 사용하면 TRACE 레벨로 지정하자.

  - INFO: 문제점 파악이 아닌 애플리케이션 상태 또는 정상적인 운영 상황에서 알아두면 좋을 정보를 위한 레벨.

  - WARN: 잠재적으로 문제가 될 만한 상황에 대한 메시지를 출력하기 위한 레벨. 해당 메시지를 확인한 사람이 취해야 할 구체적인 대책이 있어야 한다.

  - ERROR: 살펴봐야 할 에러(예. 데이터베이스 기록 작업)가 발생했을 때의 레벨. 문제를 분석하는데 충분한 정보를 제공해야 한다.

  - FATAL: 가장 위험한 수준의 메시지를 출력하기 위한 레벨. 복구 지점이나 분석 관련 데이터 같은 프로그램의 상태와 관련된 컨텍스트도 반드시 기록해야 한다.

### 로그는 원자적으로 작성하자

- 만일 데이터와 결합했을 때만 정보가 유용하다면 한 메시지에 모든 정보를 원자적으로(automically) 저장하자.

- 로그 수집기는 관련 정보를 한 줄에 모두 표현하는 로그를 더 잘 처리한다.

- 로그를 정렬할 때는 시스템 시간에 의존하지 말자.

- 로그 메시지에 개행 문자 사용 또한 피하자.

### 로그는 신속하게 기록하자

- 로그를 신속하게 기록하려면 파라미터화(parameterized)와 비동기 어펜더(appender)를 활용하자.

- 문자열 결합(string concatention) 작업은 매우 느리고 성능이 중요한 루프에 악영향을 미친다.

  ```java
  Message m = message.poll();

  // trace 레벨이 비활성화여도 결합 실행
  log.trace("got message:" + m);
  log.trace("got message: {}".format(m));

  // trace 레벨이 활성화된 경우에만 결합 실행 >> 더 빠르다
  log.trace("got message:", m);
  ```

- 어펜더(appender)는 콘솔이나 파일, 원격 로그 수집기 등 다양한 곳으로 로그를 전달한다.

  - 기본 탑재된 로그 어펜더는 print 함수처럼 호출자의 thread에서 실행된다.

  - 비동기 어펜더는 현재 실행 중인 thread에 블록하지 않고 로그 메시지를 기록하므로 애플리케이션 코드가 로그를 기록할 때까지 기다리지 않아도 되어 성능을 향상시킬 수 있다.

  - 일괄(batching) 어펜더는 로그 메시지를 디스크에 기록하기 앞서 우선 메모리에 보관하므로 쓰기 처리량이 향상된다.

- 애플리케이션에 크래시가 발생할 때 로그 메시지가 기록되지 않는 것처럼 모든 로그를 디스크에 기록하는 것은 보장되지 않는다.

- 로깅 설정을 변경함으로써 버그 또는 경합 상태(race tracing)가 보이지 않을 수 있다.

### 민감한 데이터는 로그에 기록하지 말자

- 로그 메시지에는 개인정보(비밀번호, 보안 토큰, URL, HTTP 응답 등)가 포함돼서는 안된다.

- 대부분의 프레임워크는 규칙 기반으로 문자열을 교체하거나 교정하는 기능을 제공하는데 이를 너무 의존하지는 말자.

## 애플리케이션 동작 측정을 위한 지표 활용 방안

- 지표(metrics)는 숫자로 표현한 로그같아서 애플리케이션의 동작을 측정할 수 있다.

  - 카운터(counter): 특정 이벤트가 발생한 횟수를 측정, 캐시 히트(cache hit) 카운터와 요청 카운터를 이용하면 캐시를 활용하는 비율을 계산할 수 있다.

  - 게이지(gauge): 특정 시점을 기준으로 측정하므로 값이 올라가거나 내려갈 수 있다. 큐, 스택, 맵(map) 크기 같은 통곗값을 제시해준다.

  - 히스토그램(histogram): 규모에 따라 이벤트를 특정 범위로 구분한다. 주로 요청 처리에 걸린 시간이나 데이터 페이로드(payload) 크기 같은 지표를 측정한다.

- 시스템 성능은 99백분위수처럼 임계값 백분위수(threshold percentiles)의 지표값으로 측정한다.

- 애플리케이션 지표는 데이터독(DataDog)이나 프로메테우스(Prometheus)같은 중앙식 관측용이성 시스템(observability system; 실행 중인 애플리케이션의 상태를 쉽게 알 수 있도록 수집된 지표 기반 모니터링 도구)에 수집한다.

- 오토스케일링(autoscaling)은 동적 리소스 할당을 지원하는 환경에서는 보편적으로 적용된다.

### 표준 지표 라이브러리를 사용하자

- 회사에서 원하는 라이브러리를 사용하자.

- 만약 정해진 라이브러리가 없다면 동료들과 어떤 라이브러리를 도입할지 논의하자.

- 대부분의 관측용이성 시스템은 다양한 언어를 위한 지표 클라이언트 라이브러리를 제공한다.

### 모든 것을 측정하자

- 측정(measurement)는 비용이 적게 드는 작업이므로 가급적 많은 지표를 수집해야 한다.

  - 리소스 풀(resource pool)

    - 게이지를 이용해 측정한다.

    - thread pool과 connection pool에는 좀 더 신경써야 한다.

    - pool의 크기가 커진다는 것은 시스템이 멈췄거나 계속 동작할 수 없다는 것이다.

  - 캐시

    - 캐시에서 값을 읽은 경우(cache hit)와 캐시에 값이 존재하지 않는 경우(cache miss)도 카운트하자.

    - 이 두 비율이 서로 바뀐다면 애플리케이션 성능에 영향을 미치고 있다는 것이다.

  - 데이터 구조

    - 게이지를 이용해 측정한다.

    - 데이터 구조의 크기가 비정상적으로 커지는 것은 문제가 있다는 신호다.

  - CPU 집약적 작업에 걸린 시간

    - 데이터 직렬화(serialization) 작업은 상당히 큰 비용이 드는 작업으로 특히 더 주의해야 한다.

    - 데이터 구조를 JSON으로 변환하는 단순 작업이 코드에서 가장 비용이 많이 드는 작업일 수 있다.

  - IO 집약적 작업(디스크, 네트워크 I/O 작업)

    - 느리면서 예측도 어려우므로 타이머를 이용해 얼마나 오래 걸리는지 측정하자.

    - 코드가 다루는 데이터의 크기, 원격 프로시저 호출(RTC; remote procedure call)도 측정해야 한다.

    - 데이터의 크기가 커지면 메모리 풋프린트(footprint; 실행 중일 때 사용하는 프로그램의 메모리량), IO 속도 디스크 사용량에 영향을 미친다.

  - 데이터 크기

  - 예외와 에러 응답 코드, 잘못된 입력

    - 에러를 측정하면 뭔가 잘못됐을 때 쉽게 알람을 발송할 수 있다.

  - 원격 요청 및 응답

    - 애플리케이션으로 유입되는 모든 요청을 측정하자.

    - 요청 수가 비정상적으로 높거나 낮으면 문제가 있는 것이다.

    - 신속한 응답을 위한 latency도 측정해 어느 시점에서 시스템이 느려지는지 확인하자.

- 시간을 투자해서 지표 라이브러리의 동작 방식을 이해하자.

- 대부분의 라이브러리는 샘플링(sampling) 기법을 사용하는데, 빠른 성능과 낮은 디스크 및 메모리 사용률을 유지하는 대신 측정치의 정확도가 낮아질 수 있다.

## 오늘날 분산 환경에서 더욱 중요해진 추적

- 스택 추적(stack trace)과 분산 호출 추적(distributed call trace)이 있다.

- 분산 호출 추적은 다운스트림(downstream) 호출들로 하나의 그래프를 만들어 에러 디버깅, 성능 측정, 의존성 관계, 시스템 비용 분석 등을 파악할 수 있다.

- RPC 클라이언트는 추적 라이브러리를 이용해 요청마다 호출 추적(call-trace) ID를 붙여 호출 추적 정보를 연결한다.

- 이로써 추적 시스템은 완전한 분산 호출 그래픽을 제공할 수 있다.

- 호출 추적 ID는 보통 RPC 클라이언트 래퍼(wrapper)와 서비스 메시(service mesh)에 자동으로 전달된다.

## 설정으로 런타임 동작을 손쉽게 조정하려면

- 설정 권장 기법을 적용하면 코드를 더 쉽게 실행할 수 있는데 이 때 창의성을 지나치게 발휘하지 말자.

- 표준 설정 형식을 사용하면서 적절한 기본값을 제공, 설정 입력값을 검증하고 가능하다면 동적 설정은 피하자.

- 사람이 읽기 편한 설정 파일(INI, JSON, YAML), 환경 변수, 명령줄 플래그를 사용하는 것이 가장 보편적이다.

- 사용자 정의 로직은 애플리케이션에 표시되는 설정을 모호하게 만들기도 한다.

### 지나치게 창의적인 설정은 금물이다

- 설정 시스템은 단순해야 한다.

- 원하는 동작을 할 수 있는 가장 간단한 방법(단일한 표준 형식의 정적 설정(static configuration) 파일 등)을 채택하자.

- 애플리케이션을 재시작하지 않고도 설정을 적용해야 할 때나 로그를 상세하게 표시할 때는 동적 설정(dynamic configuration) 시스템을 사용한다.

- 하지만 동적 설정은 설정 변경 추적, 다른 분산 시스템에 대한 의존성이 더해지는 복잡성 때문에 대부분 권장하지는 않는다.

- 대부분의 경우, 새로운 설정을 적용하기 위해 프로세스를 재시작하는 것이 운영과 아키텍처 면에서 가장 좋은 방법이다.

### 모든 설정을 로그에 기록하고 검증하자

- 시작 시점에 (안전한) 설정값을 로그에 기록함으로써 애플리케이션이 어떤 설정값을 사용하는지 검증하자.

- 유효한 설정값을 표현할 수 있는 견고한 타입 시스템을 갖춘 설정 시스템을 활용해보자.

### 기본값을 제공하자

- 대부분의 사용자가 시스템을 곧바로 사용할 수 있도록 적절한 기본값을 제공하자

### 관련된 설정을 그룹화하자

- 중첩을 지원하는 YAML 같은 표준 형식을 사용하자

- 강한 결합력을 가진 파라미터를 하나의 구조로 묶으면 명확한 관계를 가지면서 한 번에 선언할 수 있다.

### 설정도 코드처럼 테스트하자

- 코드로서의 설정(CAC; configuration as code)란 설정도 코드처럼 취급해야 한다는 철학이다.

- 설정은 git같은 버전 제어 시스템으로 관리해서 변경 이력을 확보하면서 리뷰하자.

### 설정 파일은 깔끔하게 유지하자

- 설정 파일이 깔끔하면 다른 사람이 이해하고 변경하기가 쉽다.

### 배포된 설정은 변경하지 말자

- 특정 머신의 설정을 수작업을 수정하는 일을 금하자.

- 일시적으로 변경한 설정은 다음 배포 과정에서 다시 원래 값으로 덮어써지면서 변경 이력을 추적하기 어렵다.

## 때로는 도구가 운영의 성패를 결정짓기도 한다

- 도구 작성에는 협업이 필요하다.

- 스크립팅이 가능한 도구는 쉽게 자동화할 수 있다.

- UI 기반 도구를 작성한다면 공통 라이브러리나 CLI 기반 도구가 쉽게 활용할 수 있는 서비스로 로직을 추상화하자.

- 시스템 도구 또한 깔끔한 코딩 표준을 지키고 철저히 테스트해야 한다.

- 표준 프레임워크에 작성하는 도구를 통합해 통합 관리 콘솔에서 사용할 수 있게 하자.

## 개발자의 필수 체크리스트

### 이것만은 지키자

- 런타임에러보다는 컴파일 타임에 에러를 검출하자.

- 가능하면 불변 변수를 사용하자.

- 입력과 출력을 검증하자.

- OWASP가 발표하는 10대 웹 애플리케이션 취약점(OWASP Top 10)은 숙지해두자.

- 버그 확인 도구는 물론 타입 또는 타입 힌트도 사용하자.

- 예외 발생 시에는 리소스(특히 소켓, 파일 포인터, 메모리 등)를 해제하자.

- 코드에 지표를 추가하자.

- 애플리케이션에 설정을 추가해두자.

- 모든 설정을 검증하고 로그에 기록하자.

### 이것만은 피하자

- 예외를 이용해 애플리케이션 로직을 결정해서는 안 된다.

- 리턴 코드로 예외를 처리해서는 안 된다.

- 처리할 수 없는 예외를 잡지 말자.

- 로그를 여러 줄로 나누지 말자.

- 보안 정보나 민감한 데이터를 로그에 기록하지 말자.

- 머신의 설정을 직접 수정하지 말자.

- 비밀번호나 보안 정보를 설정 파일에 기록하지 말자.

- 커스텀 설정 형식은 채택하지 말자.

- 불필요한 동적 설정은 사용하지 말자.

## 레벨업을 위한 읽을거리

- Code Complete(Steve MaConnell 집필, 서우석 옮김) 8장: 방어적 프로그래밍을 다룬다.

- Clean Code(Robert C.Matin 집필, 박재호 외 옮김) 7-8장: 에러 처리와 경계에 대해 설명한다.

- [Amazon Builder's Library](https://aws.amazon.com/builders-library/?cards-body.sort-by=item.additionalFields.sortDate&cards-body.sort-order=desc&awsf.filter-content-category=*all&awsf.filter-content-type=*all&awsf.filter-content-level=*all): 방어적 프로그래밍과 예외, 로깅, 설정, 도구에 대해 설명한다.

- [SRE를 위한 시스템 설계와 구축(구글 SRE 그룹 집필, 장현희 옮김)](https://sre.google/sre-book/table-of-contents/)

- [사이트 신뢰성 엔지니어링(장현희 옮김)](https://sre.google/workbook/table-of-contents/)